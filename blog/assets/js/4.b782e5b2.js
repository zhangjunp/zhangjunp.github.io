(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{358:function(t,a,v){t.exports=v.p+"assets/img/jvm.38d88865.png"},359:function(t,a,v){t.exports=v.p+"assets/img/markWord.72d1376f.png"},360:function(t,a,v){t.exports=v.p+"assets/img/jubing.8b314451.png"},361:function(t,a,v){t.exports=v.p+"assets/img/zhizhen.addeff56.png"},424:function(t,a,v){"use strict";v.r(a);var e=v(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"java的运行时内存区域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java的运行时内存区域"}},[t._v("#")]),t._v(" java的运行时内存区域")]),t._v(" "),e("h3",{attrs:{id:"摘要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[t._v("#")]),t._v(" 摘要：")]),t._v(" "),e("p",[t._v("​\tjava内存区域、各个区域存放的信息及可能出现的异常情况、对象探秘")]),t._v(" "),e("h3",{attrs:{id:"运行时区域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运行时区域"}},[t._v("#")]),t._v(" 运行时区域")]),t._v(" "),e("p",[t._v("​\tJava虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示:")]),t._v(" "),e("img",{staticStyle:{zoom:"58%"},attrs:{src:v(358),alt:"jvm"}}),t._v(" "),e("p",[t._v("方便记忆，可以按照是否是所有线程共享的进行记忆：")]),t._v(" "),e("p",[t._v("线程共享： "),e("strong",[t._v("方法区 、堆")])]),t._v(" "),e("p",[t._v("线程隔离："),e("strong",[t._v("虚拟机栈、本地方法栈、程序计数器")])]),t._v(" "),e("h4",{attrs:{id:"程序计数器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[t._v("#")]),t._v(" 程序计数器")]),t._v(" "),e("p",[t._v("​\t\t程序计数器（program counter register）是一块小的内存空间，它可以看做是"),e("strong",[t._v("当前线程所执行的字节码的行号指示器")]),t._v("。在java虚拟机的模型概念里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复的等基础功能都需要依赖这个指示器来工作；")]),t._v(" "),e("p",[t._v("​\t\t由于java虚拟机的多线程是通过"),e("strong",[t._v("线程轮流切换、分配处理器执行时间")]),t._v("的方式实现的、在任何一个确定的时刻，一个处理器都只会执行一条线程指令。因此为了"),e("strong",[t._v("线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器")]),t._v("，各条线程之间的程序计数器互相不影响，独立存储，我们称之为”线程私有“的内存；")]),t._v(" "),e("h4",{attrs:{id:"java虚拟机栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈"}},[t._v("#")]),t._v(" java虚拟机栈")]),t._v(" "),e("p",[t._v("​\t\t线程私有的，它的声明周期有线程一致。虚拟机栈描述的是java方法执行的线程内存模型:  每个方法被执行的时候，java虚拟机都会同步创建一个栈帧（Stack Frame） 用来存储 局部变量、操作数栈、动态链接、方法出口等信息、每个方法被调用直到执行完毕的过程，其实就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。")]),t._v(" "),e("p",[t._v("​\t\t**异常情况：**在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。")]),t._v(" "),e("p",[t._v("​\t"),e("em",[e("strong",[t._v("编码中，代码如果有递归调用，此时就应该注意递归深度，避免造成StackOverFlow异常")])])]),t._v(" "),e("h4",{attrs:{id:"本地方法栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[t._v("#")]),t._v(" 本地方法栈")]),t._v(" "),e("p",[t._v("​\t\t见名思议：本地方法栈和虚拟机栈 发挥的作用是非常相似的，区别在于，本地方法栈使用的是本地方法服务（Native）；")]),t._v(" "),e("p",[t._v("​\t\t"),e("strong",[t._v("异常情况")]),t._v("：栈溢出 和 内存溢出  和java虚拟机栈类似，但是我们再开发中一般接触不到，不需要过度关注")]),t._v(" "),e("h4",{attrs:{id:"java堆"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java堆"}},[t._v("#")]),t._v(" java堆")]),t._v(" "),e("p",[t._v("​\t\tJava堆（Java Heap）是虚拟机所管理的内存中最大的一块。 自从接触到java后，堆是每个程序员都知道的一块jvm内存区域；")]),t._v(" "),e("p",[t._v("Java堆是被所有线程功效的一块内存区域，在虚拟机启动时创建。在此内存区域的唯一目的就是存放对象实例，Java世界中"),e("strong",[t._v("几乎")]),t._v("所有的对象都在这里进行分配；")]),t._v(" "),e("p",[t._v("​\t\t"),e("strong",[t._v("异常情况")]),t._v("：当java堆中没有内存完成实例分配，并且堆也无法再扩展时，java虚拟机会抛出oom异常")]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("h4",{attrs:{id:"方法区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[t._v("#")]),t._v(" 方法区")]),t._v(" "),e("p",[t._v("​\t方法区与java堆一样是各个线程共享的内存区域，他存储已被虚拟机加载的"),e("strong",[t._v("类型信息、常量、静态变量、即时编译器编译后的代码缓存")]),t._v("等数据；")]),t._v(" "),e("p",[t._v("​\t方法区经常有被称之为“永久代”，在JDK1.8之前，许多程序员都习惯在HotSpot虚拟机上开发和部署程序，很多人都愿意将方法区称之为“永久代（Permanent Generation）”，或者有的直接将两者等价混为一谈。")]),t._v(" "),e("p",[t._v("​\t本质上两者不是等价的，这么叫仅仅是因为虚拟机的设计团队，将收集器的分代设计扩张到了方法区，或者说使用“永久代”来实现方法区而已；这样就省去了专门为方法区编写内存管理的代码；")]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("p",[t._v("​\t"),e("strong",[t._v("方法区内存回收实现发展史：")])]),t._v(" "),e("p",[t._v("​\t考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。")]),t._v(" "),e("h4",{attrs:{id:"运行时常量池"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池"}},[t._v("#")]),t._v(" 运行时常量池")]),t._v(" "),e("p",[t._v("​\t\t运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。")]),t._v(" "),e("p",[e("strong",[t._v("异常情况")]),t._v("：如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。")]),t._v(" "),e("h4",{attrs:{id:"直接内存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#直接内存"}},[t._v("#")]),t._v(" 直接内存")]),t._v(" "),e("p",[t._v("​\t直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。")]),t._v(" "),e("p",[t._v("​\t在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。")]),t._v(" "),e("h3",{attrs:{id:"hotspot虚拟机对象探秘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hotspot虚拟机对象探秘"}},[t._v("#")]),t._v(" HotSpot虚拟机对象探秘")]),t._v(" "),e("p",[t._v("​\t\t更进一步想了解这些虚拟机内存中数据的其他细节，譬如它们是如 何创建、如何布局以及如何访问的。对于这样涉及细节的问题，必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域上才有意义。基于实用优先的原则，笔者以最常用的虚拟机HotSpot和最常用的内存区域Java堆为例，深入探讨一下HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。")]),t._v(" "),e("h4",{attrs:{id:"对象的创建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象的创建"}},[t._v("#")]),t._v(" 对象的创建")]),t._v(" "),e("p",[t._v("​\t   Java是一门面向对象语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象（排除 复制 反序列化）通常仅仅是一个New关键字而已，下边来了解一下对象的创建过程（ps：下边讨论的对象限于普通的Java对象，不包括数组和Class对象）")]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Step1： 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程;")])]),t._v(" "),e("li",[e("p",[t._v("Step2： 为对象分配内存（对象所需的内存大小在类加载后就能确定），如何划分内存呢？ 有两种方式吧，一种是 "),e("strong",[t._v("指针碰撞")]),t._v(" ；另外一种"),e("strong",[t._v("空闲列表")]),t._v("；到底采取哪种分配方式，需要看具体jvm堆内存是如何进行管理的，具体和jvm的垃圾收集器是否带"),e("strong",[t._v("空间压缩")]),t._v("；")])]),t._v(" "),e("li",[e("p",[t._v("Step3：并发情况下，如何保证线程安全？ 一种采取同步处理方式，CAS加锁+失败后重试 ；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。")])]),t._v(" "),e("li",[e("p",[t._v("Step4:  内存分配完成后，一个新的对象在虚拟机视角来看已经产生了。这时候会设置初始值、类的元信息、对象的hashCode码（通常会延后生成）、GC分代年龄、以及是否启用偏向锁")])]),t._v(" "),e("li",[e("p",[t._v("Step5：到这一步后，才会执行我们coding的代码，执行Class的构造方法。这个步骤对象需要的其他资源和状态信息会按照我们预定的意图构造好；一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行< init >()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。")]),t._v(" "),e("p",[e("em",[e("strong",[e("u",[t._v("PS:")])])]),t._v("   强调“理论上”是因为在CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作Linear Allocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指针碰撞方式来分配。")])])]),t._v(" "),e("h4",{attrs:{id:"对象的内存布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象的内存布局"}},[t._v("#")]),t._v(" 对象的内存布局")]),t._v(" "),e("p",[t._v("​\t\t在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为3个部分： "),e("strong",[t._v("对象头（Header）")]),t._v("、"),e("strong",[t._v("实例数据（Instance Data）")]),t._v("、"),e("strong",[t._v("对齐填充（Padding）")]),t._v("。")]),t._v(" "),e("h5",{attrs:{id:"对象头-header"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象头-header"}},[t._v("#")]),t._v(" 对象头（Header）")]),t._v(" "),e("p",[t._v("​\t\t第一类： 用于存储对象自身运行时数据，如 哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；")]),t._v(" "),e("img",{staticStyle:{zoom:"80%"},attrs:{src:v(359)}}),t._v(" "),e("p",[t._v("​\t\t第二类： 是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。")]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("p",[t._v("​\tHotSpot虚拟机代表Mark Word中的代码（markOop.cpp）注释片段，它描述了32位虚拟机Mark Word的存储布局：")]),t._v(" "),e("p",[e("code",[t._v("// Bit-format of an object header (most significant first, big endian layout below):")])]),t._v(" "),e("p",[e("code",[t._v("// 32 bits:")])]),t._v(" "),e("p",[e("code",[t._v("// --------")])]),t._v(" "),e("p",[e("code",[t._v("// hash:25 ------------\x3e| age:4 biased_lock:1 lock:2 (normal object)// JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object)")])]),t._v(" "),e("p",[e("code",[t._v("// size:32 ------------------------------------------\x3e| (CMS free block)")])]),t._v(" "),e("p",[e("code",[t._v("// PromotedObject*:29 ----------\x3e| promo_bits:3 -----\x3e| (CMS promoted object)")])]),t._v(" "),e("h5",{attrs:{id:"实例数据-instance-data"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例数据-instance-data"}},[t._v("#")]),t._v(" 实例数据（Instance Data）")]),t._v(" "),e("p",[t._v("​\t\t实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字 段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。")]),t._v(" "),e("p",[t._v("​\t\t这部分的存储顺序会 受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。")]),t._v(" "),e("p",[t._v("​\t    HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存 放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的 +XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。")]),t._v(" "),e("h5",{attrs:{id:"对齐填充-padding"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对齐填充-padding"}},[t._v("#")]),t._v(" 对齐填充（Padding）")]),t._v(" "),e("p",[t._v("​\t\t对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作 用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是 任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者 2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。")]),t._v(" "),e("h4",{attrs:{id:"对象的访问定位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象的访问定位"}},[t._v("#")]),t._v(" 对象的访问定位")]),t._v(" "),e("p",[t._v("​\t创建对象后，自然是为了后续使用此对象，我门Java程序会通过栈上的Reference数据来操作堆上的具体对象。由于Reference类型在《java虚拟机规范》中没有定义具体的事项方式，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式分为   "),e("strong",[t._v("使用句柄")]),t._v(" 和  "),e("strong",[t._v("直接指针")]),t._v(" 两种")]),t._v(" "),e("h5",{attrs:{id:"使用句柄"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用句柄"}},[t._v("#")]),t._v(" 使用句柄")]),t._v(" "),e("p",[t._v("​\t\t使用句柄来访问的最大好处就是reference中存储的是稳定句柄地 址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。")]),t._v(" "),e("img",{staticStyle:{zoom:"77%"},attrs:{src:v(360),alt:"image-20210105143404023"}}),t._v(" "),e("h5",{attrs:{id:"直接指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#直接指针"}},[t._v("#")]),t._v(" 直接指针")]),t._v(" "),e("p",[t._v("​\t\t使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟 机HotSpot而言，它主要使用第二种方式进行对象访问（有例外情况，如果使用了Shenandoah收集器的 话也会有一次额外的转发，具体可参见第3章），但从整个软件开发的范围来看，在各种语言、框架中使用句柄来访问的情况也十分常见。")]),t._v(" "),e("img",{staticStyle:{zoom:"77%"},attrs:{src:v(361),alt:"zhizhen"}})])}),[],!1,null,null,null);a.default=r.exports}}]);